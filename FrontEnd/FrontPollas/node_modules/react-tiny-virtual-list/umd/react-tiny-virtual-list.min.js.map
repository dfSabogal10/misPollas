{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-tiny-virtual-list.min.js","webpack:///webpack/bootstrap 3d6e39e069e93efb824f","webpack:///./src/constants.js","webpack:///./src/index.js","webpack:///./src/SizeAndPositionManager.js","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_3__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","ALIGN_START","ALIGN_CENTER","ALIGN_END","DIRECTION_VERTICAL","scrollProp","sizeProp","positionProp","_scrollProp","_sizeProp","_positionProp","DIRECTION_HORIZONTAL","_objectWithoutProperties","obj","keys","target","indexOf","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","__WEBPACK_IMPORTED_MODULE_1__SizeAndPositionManager__","__WEBPACK_IMPORTED_MODULE_2__constants__","VirtualList","_class","_temp2","_extends","assign","arguments","length","source","key","STYLE_WRAPPER","overflow","willChange","WebkitOverflowScrolling","STYLE_INNER","position","width","minHeight","STYLE_ITEM","left","_PureComponent","_temp","_this","_ret","_len","args","Array","_key","apply","concat","sizeAndPositionManager","itemCount","props","itemSizeGetter","_ref","index","getSize","estimatedItemSize","itemSize","state","offset","scrollOffset","scrollToIndex","getOffsetForIndex","_styleCache","_getRef","node","rootNode","handleScroll","e","onScroll","getNodeOffset","setState","componentDidMount","_props","scrollDirection","scrollTo","componentWillReceiveProps","nextProps","_props2","scrollToAlignment","recomputeSizes","componentDidUpdate","nextState","_state","undefined","getUpdatedOffsetForIndex","align","containerSize","targetIndex","isArray","getStyle","_extends2","style","_sizeAndPositionManag","getSizeAndPositionForIndex","size","startIndex","resetItem","render","_extends3","_props3","height","overscanCount","renderItem","_sizeAndPositionManag2","getVisibleRange","start","stop","items","push","a","createElement","ref","getTotalSize","defaultProps","__WEBPACK_IMPORTED_MODULE_0__constants__","SizeAndPositionManager","_itemSizeGetter","_itemCount","_estimatedItemSize","_itemSizeAndPositionData","_lastMeasuredIndex","getLastMeasuredIndex","Error","lastMeasuredSizeAndPosition","getSizeAndPositionOfLastMeasuredItem","isNaN","_ref2","_ref2$align","datum","maxOffset","minOffset","idealOffset","totalSize","Math","max","min","_ref3","_findNearestItem","_binarySearch","_ref4","low","high","middle","currentOffset","floor","_exponentialSearch","_ref5","interval","lastMeasuredIndex"],"mappings":"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","file":"react-tiny-virtual-list.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VirtualList\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"VirtualList\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VirtualList\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"VirtualList\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return ALIGN_START; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return ALIGN_CENTER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return ALIGN_END; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return DIRECTION_VERTICAL; });\n/* unused harmony export DIRECTION_HORIZONTAL */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return scrollProp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return sizeProp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return positionProp; });\nvar _scrollProp, _sizeProp, _positionProp;\n\nvar ALIGN_START = 'start';\nvar ALIGN_CENTER = 'center';\nvar ALIGN_END = 'end';\nvar DIRECTION_VERTICAL = 'vertical';\nvar DIRECTION_HORIZONTAL = 'horizontal';\n\nvar scrollProp = (_scrollProp = {}, _scrollProp[DIRECTION_VERTICAL] = 'scrollTop', _scrollProp[DIRECTION_HORIZONTAL] = 'scrollLeft', _scrollProp);\nvar sizeProp = (_sizeProp = {}, _sizeProp[DIRECTION_VERTICAL] = 'height', _sizeProp[DIRECTION_HORIZONTAL] = 'width', _sizeProp);\nvar positionProp = (_positionProp = {}, _positionProp[DIRECTION_VERTICAL] = 'top', _positionProp[DIRECTION_HORIZONTAL] = 'left', _positionProp);\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SizeAndPositionManager__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(0);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return VirtualList; });\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _class, _temp2;\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar STYLE_WRAPPER = { overflow: 'auto', willChange: 'transform', WebkitOverflowScrolling: 'touch' };\nvar STYLE_INNER = { position: 'relative', overflow: 'hidden', width: '100%', minHeight: '100%' };\nvar STYLE_ITEM = { position: 'absolute', left: 0, width: '100%' };\n\nvar VirtualList = (_temp2 = _class = function (_PureComponent) {\n  _inherits(VirtualList, _PureComponent);\n\n  function VirtualList() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, VirtualList);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.sizeAndPositionManager = new __WEBPACK_IMPORTED_MODULE_1__SizeAndPositionManager__[\"a\" /* default */]({\n      itemCount: _this.props.itemCount,\n      itemSizeGetter: function itemSizeGetter(_ref) {\n        var index = _ref.index;\n        return _this.getSize(index);\n      },\n      estimatedItemSize: _this.props.estimatedItemSize || typeof _this.props.itemSize === \"number\" && _this.props.itemSize || 50\n    }), _this.state = {\n      offset: _this.props.scrollOffset || _this.props.scrollToIndex != null && _this.getOffsetForIndex(_this.props.scrollToIndex) || 0\n    }, _this._styleCache = {}, _this._getRef = function (node) {\n      _this.rootNode = node;\n    }, _this.handleScroll = function (e) {\n      var onScroll = _this.props.onScroll;\n\n      var offset = _this.getNodeOffset();\n\n      _this.setState({ offset: offset });\n\n      if (typeof onScroll === 'function') {\n        onScroll(offset, e);\n      }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  VirtualList.prototype.componentDidMount = function componentDidMount() {\n    var _props = this.props,\n        scrollDirection = _props.scrollDirection,\n        scrollOffset = _props.scrollOffset,\n        scrollToIndex = _props.scrollToIndex;\n\n\n    if (scrollOffset != null) {\n      this.scrollTo(scrollOffset);\n    } else if (scrollToIndex != null) {\n      this.scrollTo(this.getOffsetForIndex(scrollToIndex));\n    }\n  };\n\n  VirtualList.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var _props2 = this.props,\n        itemSize = _props2.itemSize,\n        scrollOffset = _props2.scrollOffset,\n        scrollToAlignment = _props2.scrollToAlignment,\n        scrollToIndex = _props2.scrollToIndex;\n\n\n    if (nextProps.scrollOffset !== scrollOffset) {\n      this.setState({\n        offset: nextProps.scrollOffset\n      });\n    } else if (nextProps.scrollToIndex !== scrollToIndex || nextProps.scrollToAlignment !== scrollToAlignment) {\n      this.setState({\n        offset: this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment)\n      });\n    }\n\n    if (nextProps.itemSize !== itemSize) {\n      this.recomputeSizes();\n    }\n  };\n\n  VirtualList.prototype.componentDidUpdate = function componentDidUpdate(nextProps, nextState) {\n    var _state = this.state,\n        scrollDirection = _state.scrollDirection,\n        offset = _state.offset;\n\n\n    if (nextState.offset !== offset) {\n      this.scrollTo(offset);\n    }\n  };\n\n  VirtualList.prototype.getNodeOffset = function getNodeOffset() {\n    var scrollDirection = this.props.scrollDirection;\n\n    return this.rootNode[__WEBPACK_IMPORTED_MODULE_2__constants__[\"a\" /* scrollProp */][scrollDirection]];\n  };\n\n  VirtualList.prototype.scrollTo = function scrollTo(value) {\n    var scrollDirection = this.props.scrollDirection;\n\n    this.rootNode[__WEBPACK_IMPORTED_MODULE_2__constants__[\"a\" /* scrollProp */][scrollDirection]] = value;\n  };\n\n  VirtualList.prototype.getOffsetForIndex = function getOffsetForIndex(index) {\n    var scrollToAlignment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.scrollToAlignment;\n    var scrollDirection = this.props.scrollDirection;\n\n\n    return this.sizeAndPositionManager.getUpdatedOffsetForIndex({\n      align: scrollToAlignment,\n      containerSize: this.props[__WEBPACK_IMPORTED_MODULE_2__constants__[\"b\" /* sizeProp */][scrollDirection]],\n      targetIndex: index\n    });\n  };\n\n  VirtualList.prototype.getSize = function getSize(index) {\n    var itemSize = this.props.itemSize;\n\n\n    if (typeof itemSize === 'function') {\n      return itemSize(index);\n    }\n\n    return Array.isArray(itemSize) ? itemSize[index] : itemSize;\n  };\n\n  VirtualList.prototype.getStyle = function getStyle(index) {\n    var _extends2;\n\n    var style = this._styleCache[index];\n    if (style) {\n      return style;\n    }\n\n    var scrollDirection = this.props.scrollDirection;\n\n    var _sizeAndPositionManag = this.sizeAndPositionManager.getSizeAndPositionForIndex(index),\n        size = _sizeAndPositionManag.size,\n        offset = _sizeAndPositionManag.offset;\n\n    return this._styleCache[index] = _extends({}, STYLE_ITEM, (_extends2 = {}, _extends2[__WEBPACK_IMPORTED_MODULE_2__constants__[\"b\" /* sizeProp */][scrollDirection]] = size, _extends2[__WEBPACK_IMPORTED_MODULE_2__constants__[\"c\" /* positionProp */][scrollDirection]] = offset, _extends2));\n  };\n\n  VirtualList.prototype.recomputeSizes = function recomputeSizes() {\n    var startIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    this._styleCache = {};\n    this.sizeAndPositionManager.resetItem(startIndex);\n  };\n\n  VirtualList.prototype.render = function render() {\n    var _extends3;\n\n    var _props3 = this.props,\n        estimatedItemSize = _props3.estimatedItemSize,\n        height = _props3.height,\n        overscanCount = _props3.overscanCount,\n        renderItem = _props3.renderItem,\n        itemCount = _props3.itemCount,\n        itemSize = _props3.itemSize,\n        scrollDirection = _props3.scrollDirection,\n        scrollOffset = _props3.scrollOffset,\n        scrollToIndex = _props3.scrollToIndex,\n        scrollToAlignment = _props3.scrollToAlignment,\n        style = _props3.style,\n        width = _props3.width,\n        props = _objectWithoutProperties(_props3, ['estimatedItemSize', 'height', 'overscanCount', 'renderItem', 'itemCount', 'itemSize', 'scrollDirection', 'scrollOffset', 'scrollToIndex', 'scrollToAlignment', 'style', 'width']);\n\n    var offset = this.state.offset;\n\n    var _sizeAndPositionManag2 = this.sizeAndPositionManager.getVisibleRange({\n      containerSize: this.props[__WEBPACK_IMPORTED_MODULE_2__constants__[\"b\" /* sizeProp */][scrollDirection]],\n      offset: offset,\n      overscanCount: overscanCount\n    }),\n        start = _sizeAndPositionManag2.start,\n        stop = _sizeAndPositionManag2.stop;\n\n    var items = [];\n\n    for (var index = start; index < stop; index++) {\n      items.push(renderItem({\n        index: index,\n        style: this.getStyle(index)\n      }));\n    }\n\n    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\n      'div',\n      _extends({ ref: this._getRef }, props, { onScroll: this.handleScroll, style: _extends({}, STYLE_WRAPPER, style, { height: height, width: width }) }),\n      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\n        'div',\n        { style: _extends({}, STYLE_INNER, (_extends3 = {}, _extends3[__WEBPACK_IMPORTED_MODULE_2__constants__[\"b\" /* sizeProp */][scrollDirection]] = this.sizeAndPositionManager.getTotalSize(), _extends3)) },\n        items\n      )\n    );\n  };\n\n  return VirtualList;\n}(__WEBPACK_IMPORTED_MODULE_0_react__[\"PureComponent\"]), _class.defaultProps = {\n  overscanCount: 3,\n  scrollDirection: __WEBPACK_IMPORTED_MODULE_2__constants__[\"d\" /* DIRECTION_VERTICAL */],\n  width: '100%'\n}, _temp2);\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(0);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return SizeAndPositionManager; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* Forked from react-virtualized 💖 */\n\n\nvar SizeAndPositionManager = function () {\n  function SizeAndPositionManager(_ref) {\n    var itemCount = _ref.itemCount,\n        itemSizeGetter = _ref.itemSizeGetter,\n        estimatedItemSize = _ref.estimatedItemSize;\n\n    _classCallCheck(this, SizeAndPositionManager);\n\n    this._itemSizeGetter = itemSizeGetter;\n    this._itemCount = itemCount;\n    this._estimatedItemSize = estimatedItemSize;\n\n    // Cache of size and position data for items, mapped by item index.\n    this._itemSizeAndPositionData = {};\n\n    // Measurements for items up to this index can be trusted; items afterward should be estimated.\n    this._lastMeasuredIndex = -1;\n  }\n\n  SizeAndPositionManager.prototype.getLastMeasuredIndex = function getLastMeasuredIndex() {\n    return this._lastMeasuredIndex;\n  };\n\n  /**\n   * This method returns the size and position for the item at the specified index.\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\n   */\n\n\n  SizeAndPositionManager.prototype.getSizeAndPositionForIndex = function getSizeAndPositionForIndex(index) {\n    if (index < 0 || index >= this._itemCount) {\n      throw Error('Requested index ' + index + ' is outside of range 0..' + this._itemCount);\n    }\n\n    if (index > this._lastMeasuredIndex) {\n      var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n      var offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\n\n      for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {\n        var size = this._itemSizeGetter({ index: i });\n\n        if (size == null || isNaN(size)) {\n          throw Error('Invalid size returned for index ' + i + ' of value ' + size);\n        }\n\n        this._itemSizeAndPositionData[i] = {\n          offset: offset,\n          size: size\n        };\n\n        offset += size;\n      }\n\n      this._lastMeasuredIndex = index;\n    }\n\n    return this._itemSizeAndPositionData[index];\n  };\n\n  SizeAndPositionManager.prototype.getSizeAndPositionOfLastMeasuredItem = function getSizeAndPositionOfLastMeasuredItem() {\n    return this._lastMeasuredIndex >= 0 ? this._itemSizeAndPositionData[this._lastMeasuredIndex] : { offset: 0, size: 0 };\n  };\n\n  /**\n  * Total size of all items being measured.\n  * This value will be completedly estimated initially.\n  * As items as measured the estimate will be updated.\n  */\n\n\n  SizeAndPositionManager.prototype.getTotalSize = function getTotalSize() {\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n\n    return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this._itemCount - this._lastMeasuredIndex - 1) * this._estimatedItemSize;\n  };\n\n  /**\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\n   *\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @return Offset to use to ensure the specified item is visible\n   */\n\n\n  SizeAndPositionManager.prototype.getUpdatedOffsetForIndex = function getUpdatedOffsetForIndex(_ref2) {\n    var _ref2$align = _ref2.align,\n        align = _ref2$align === undefined ? __WEBPACK_IMPORTED_MODULE_0__constants__[\"e\" /* ALIGN_START */] : _ref2$align,\n        containerSize = _ref2.containerSize,\n        targetIndex = _ref2.targetIndex;\n\n    if (containerSize <= 0) {\n      return 0;\n    }\n\n    var datum = this.getSizeAndPositionForIndex(targetIndex);\n    var maxOffset = datum.offset;\n    var minOffset = maxOffset - containerSize + datum.size;\n\n    var idealOffset = void 0;\n\n    switch (align) {\n      case __WEBPACK_IMPORTED_MODULE_0__constants__[\"f\" /* ALIGN_END */]:\n        idealOffset = minOffset;\n        break;\n      case __WEBPACK_IMPORTED_MODULE_0__constants__[\"g\" /* ALIGN_CENTER */]:\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n      default:\n        idealOffset = maxOffset;\n        break;\n    }\n\n    var totalSize = this.getTotalSize();\n\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  };\n\n  SizeAndPositionManager.prototype.getVisibleRange = function getVisibleRange(_ref3) {\n    var containerSize = _ref3.containerSize,\n        offset = _ref3.offset,\n        overscanCount = _ref3.overscanCount;\n\n    var totalSize = this.getTotalSize();\n\n    if (totalSize === 0) {\n      return {};\n    }\n\n    var maxOffset = offset + containerSize;\n    var start = this._findNearestItem(offset);\n    var stop = start;\n\n    var datum = this.getSizeAndPositionForIndex(start);\n    offset = datum.offset + datum.size;\n\n    while (offset < maxOffset && stop < this._itemCount - 1) {\n      stop++;\n      offset += this.getSizeAndPositionForIndex(stop).size;\n    }\n\n    if (overscanCount) {\n      start = Math.max(0, start - overscanCount);\n      stop = Math.min(stop + overscanCount, this._itemCount);\n    }\n\n    return {\n      start: start,\n      stop: stop\n    };\n  };\n\n  /**\n   * Clear all cached values for items after the specified index.\n   * This method should be called for any item that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n   */\n\n\n  SizeAndPositionManager.prototype.resetItem = function resetItem(index) {\n    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n  };\n\n  SizeAndPositionManager.prototype._binarySearch = function _binarySearch(_ref4) {\n    var low = _ref4.low,\n        high = _ref4.high,\n        offset = _ref4.offset;\n\n    var middle = void 0;\n    var currentOffset = void 0;\n\n    while (low <= high) {\n      middle = low + Math.floor((high - low) / 2);\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n\n      if (currentOffset === offset) {\n        return middle;\n      } else if (currentOffset < offset) {\n        low = middle + 1;\n      } else if (currentOffset > offset) {\n        high = middle - 1;\n      }\n    }\n\n    if (low > 0) {\n      return low - 1;\n    }\n  };\n\n  SizeAndPositionManager.prototype._exponentialSearch = function _exponentialSearch(_ref5) {\n    var index = _ref5.index,\n        offset = _ref5.offset;\n\n    var interval = 1;\n\n    while (index < this._itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {\n      index += interval;\n      interval *= 2;\n    }\n\n    return this._binarySearch({\n      high: Math.min(index, this._itemCount - 1),\n      low: Math.floor(index / 2),\n      offset: offset\n    });\n  };\n\n  /**\n   * Searches for the item (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest item index will be returned.\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\n   */\n\n\n  SizeAndPositionManager.prototype._findNearestItem = function _findNearestItem(offset) {\n    if (isNaN(offset)) {\n      throw Error('Invalid offset ' + offset + ' specified');\n    }\n\n    // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n    offset = Math.max(0, offset);\n\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    var lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);\n\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\n      // If we've already measured items within this range just use a binary search as it's faster.\n      return this._binarySearch({\n        high: lastMeasuredIndex,\n        low: 0,\n        offset: offset\n      });\n    } else {\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n      // The overall complexity for this approach is O(log n).\n      return this._exponentialSearch({\n        index: lastMeasuredIndex,\n        offset: offset\n      });\n    }\n  };\n\n  return SizeAndPositionManager;\n}();\n\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// react-tiny-virtual-list.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3d6e39e069e93efb824f","export const ALIGN_START = 'start';\nexport const ALIGN_CENTER = 'center';\nexport const ALIGN_END = 'end';\nexport const DIRECTION_VERTICAL = 'vertical';\nexport const DIRECTION_HORIZONTAL = 'horizontal';\n\nexport const scrollProp = {\n  [DIRECTION_VERTICAL]: 'scrollTop',\n  [DIRECTION_HORIZONTAL]: 'scrollLeft',\n};\nexport const sizeProp = {\n  [DIRECTION_VERTICAL]: 'height',\n  [DIRECTION_HORIZONTAL]: 'width',\n};\nexport const positionProp = {\n  [DIRECTION_VERTICAL]: 'top',\n  [DIRECTION_HORIZONTAL]: 'left',\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants.js","import React, {PureComponent, PropTypes} from 'react';\nimport SizeAndPositionManager from './SizeAndPositionManager';\nimport {\n  ALIGN_CENTER,\n  ALIGN_END,\n  ALIGN_START,\n  DIRECTION_VERTICAL,\n  DIRECTION_HORIZONTAL,\n  positionProp,\n  scrollProp,\n  sizeProp,\n} from './constants';\n\nconst STYLE_WRAPPER = {overflow: 'auto', willChange: 'transform', WebkitOverflowScrolling: 'touch'};\nconst STYLE_INNER = {position: 'relative', overflow: 'hidden', width: '100%', minHeight: '100%'};\nconst STYLE_ITEM = {position: 'absolute', left: 0, width: '100%'};\n\nexport default class VirtualList extends PureComponent {\n  static defaultProps = {\n    overscanCount: 3,\n    scrollDirection: DIRECTION_VERTICAL,\n    width: '100%',\n  };\n  static propTypes = {\n    estimatedItemSize: PropTypes.number,\n    height: PropTypes.number.isRequired,\n    itemCount: PropTypes.number.isRequired,\n    itemSize: PropTypes.oneOfType([PropTypes.number, PropTypes.array, PropTypes.func]).isRequired,\n    overscanCount: PropTypes.number,\n    renderItem: PropTypes.func.isRequired,\n    scrollOffset: PropTypes.number,\n    scrollToIndex: PropTypes.number,\n    scrollToAlignment: PropTypes.oneOf([ALIGN_START, ALIGN_CENTER, ALIGN_END]),\n    scrollDirection: PropTypes.oneOf([DIRECTION_HORIZONTAL, DIRECTION_VERTICAL]).isRequired,\n    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  }\n\n  sizeAndPositionManager = new SizeAndPositionManager({\n    itemCount: this.props.itemCount,\n    itemSizeGetter: ({index}) => this.getSize(index),\n    estimatedItemSize: this.props.estimatedItemSize || typeof this.props.itemSize === \"number\" && this.props.itemSize || 50,\n  });\n\n  state = {\n    offset: (\n      this.props.scrollOffset ||\n      this.props.scrollToIndex != null && this.getOffsetForIndex(this.props.scrollToIndex) ||\n      0\n    ),\n  };\n\n  _styleCache = {};\n\n  _getRef = node => {\n    this.rootNode = node;\n  };\n\n  componentDidMount() {\n    const {scrollDirection, scrollOffset, scrollToIndex} = this.props;\n\n    if (scrollOffset != null) {\n      this.scrollTo(scrollOffset);\n    } else if (scrollToIndex != null) {\n      this.scrollTo(this.getOffsetForIndex(scrollToIndex));\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const {itemSize, scrollOffset, scrollToAlignment, scrollToIndex} = this.props;\n\n    if (nextProps.scrollOffset !== scrollOffset) {\n      this.setState({\n        offset: nextProps.scrollOffset\n      });\n    } else if (\n      nextProps.scrollToIndex !== scrollToIndex ||\n      nextProps.scrollToAlignment !== scrollToAlignment\n    ) {\n      this.setState({\n        offset: this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment)\n      });\n    }\n\n    if (nextProps.itemSize !== itemSize) {\n      this.recomputeSizes();\n    }\n  }\n\n  componentDidUpdate(nextProps, nextState) {\n    const {scrollDirection, offset} = this.state;\n\n    if (nextState.offset !== offset) {\n      this.scrollTo(offset);\n    }\n  }\n\n  handleScroll = e => {\n    const {onScroll} = this.props;\n    const offset = this.getNodeOffset();\n\n    this.setState({offset});\n\n    if (typeof onScroll === 'function') {\n      onScroll(offset, e);\n    }\n  };\n\n  getNodeOffset() {\n    const {scrollDirection} = this.props;\n    return this.rootNode[scrollProp[scrollDirection]];\n  }\n\n  scrollTo(value) {\n    const {scrollDirection} = this.props;\n    this.rootNode[scrollProp[scrollDirection]] = value;\n  }\n\n  getOffsetForIndex(index, scrollToAlignment = this.props.scrollToAlignment) {\n    const {scrollDirection} = this.props;\n\n    return this.sizeAndPositionManager.getUpdatedOffsetForIndex({\n      align: scrollToAlignment,\n      containerSize: this.props[sizeProp[scrollDirection]],\n      targetIndex: index,\n    });\n  }\n\n  getSize(index) {\n    const {itemSize} = this.props;\n\n    if (typeof itemSize === 'function') { return itemSize(index); }\n\n    return Array.isArray(itemSize) ? itemSize[index] : itemSize;\n  }\n\n  getStyle(index) {\n    const style = this._styleCache[index];\n    if (style) { return style; }\n\n    const {scrollDirection} = this.props;\n    const {size, offset} = this.sizeAndPositionManager.getSizeAndPositionForIndex(index);\n\n    return this._styleCache[index] = {\n      ...STYLE_ITEM,\n      [sizeProp[scrollDirection]]: size,\n      [positionProp[scrollDirection]]: offset,\n    };\n  }\n\n  recomputeSizes(startIndex = 0) {\n    this._styleCache = {};\n    this.sizeAndPositionManager.resetItem(startIndex);\n  }\n\n  render() {\n    const {\n      estimatedItemSize,\n      height,\n      overscanCount,\n      renderItem,\n      itemCount,\n      itemSize,\n      scrollDirection,\n      scrollOffset,\n      scrollToIndex,\n      scrollToAlignment,\n      style,\n      width,\n      ...props\n    } = this.props;\n    const {offset} = this.state;\n    const {start, stop} = this.sizeAndPositionManager.getVisibleRange({\n      containerSize: this.props[sizeProp[scrollDirection]],\n      offset,\n      overscanCount,\n    });\n    const items = [];\n\n    for (let index = start; index < stop; index++) {\n      items.push(renderItem({\n        index,\n        style: this.getStyle(index),\n      }));\n    }\n\n    return (\n      <div ref={this._getRef} {...props} onScroll={this.handleScroll} style={{...STYLE_WRAPPER, ...style, height, width}}>\n        <div style={{...STYLE_INNER, [sizeProp[scrollDirection]]: this.sizeAndPositionManager.getTotalSize()}}>\n          {items}\n        </div>\n      </div>\n    );\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/* Forked from react-virtualized 💖 */\nimport {ALIGN_START, ALIGN_END, ALIGN_CENTER} from './constants';\n\nexport default class SizeAndPositionManager {\n  constructor({\n    itemCount,\n    itemSizeGetter,\n    estimatedItemSize,\n  }) {\n    this._itemSizeGetter = itemSizeGetter;\n    this._itemCount = itemCount;\n    this._estimatedItemSize = estimatedItemSize;\n\n    // Cache of size and position data for items, mapped by item index.\n    this._itemSizeAndPositionData = {};\n\n    // Measurements for items up to this index can be trusted; items afterward should be estimated.\n    this._lastMeasuredIndex = -1;\n  }\n\n  getLastMeasuredIndex() {\n    return this._lastMeasuredIndex;\n  }\n\n  /**\n   * This method returns the size and position for the item at the specified index.\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\n   */\n  getSizeAndPositionForIndex(index) {\n    if (index < 0 || index >= this._itemCount) {\n      throw Error(`Requested index ${index} is outside of range 0..${this._itemCount}`);\n    }\n\n    if (index > this._lastMeasuredIndex) {\n      let lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n      let offset = lastMeasuredSizeAndPosition.offset +\n        lastMeasuredSizeAndPosition.size;\n\n      for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {\n        let size = this._itemSizeGetter({index: i});\n\n        if (size == null || isNaN(size)) {\n          throw Error(`Invalid size returned for index ${i} of value ${size}`);\n        }\n\n        this._itemSizeAndPositionData[i] = {\n          offset,\n          size,\n        };\n\n        offset += size;\n      }\n\n      this._lastMeasuredIndex = index;\n    }\n\n    return this._itemSizeAndPositionData[index];\n  }\n\n  getSizeAndPositionOfLastMeasuredItem() {\n    return this._lastMeasuredIndex >= 0\n      ? this._itemSizeAndPositionData[this._lastMeasuredIndex]\n      : {offset: 0, size: 0};\n  }\n\n  /**\n  * Total size of all items being measured.\n  * This value will be completedly estimated initially.\n  * As items as measured the estimate will be updated.\n  */\n  getTotalSize() {\n    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n\n    return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this._itemCount - this._lastMeasuredIndex - 1) * this._estimatedItemSize;\n  }\n\n  /**\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\n   *\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @return Offset to use to ensure the specified item is visible\n   */\n  getUpdatedOffsetForIndex({\n    align = ALIGN_START,\n    containerSize,\n    targetIndex,\n  }) {\n    if (containerSize <= 0) {\n      return 0;\n    }\n\n    const datum = this.getSizeAndPositionForIndex(targetIndex);\n    const maxOffset = datum.offset;\n    const minOffset = maxOffset - containerSize + datum.size;\n\n    let idealOffset;\n\n    switch (align) {\n      case ALIGN_END:\n        idealOffset = minOffset;\n        break;\n      case ALIGN_CENTER:\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n      default:\n        idealOffset = maxOffset;\n        break;\n    }\n\n    const totalSize = this.getTotalSize();\n\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  }\n\n  getVisibleRange({containerSize, offset, overscanCount}) {\n    const totalSize = this.getTotalSize();\n\n    if (totalSize === 0) { return {}; }\n\n    const maxOffset = offset + containerSize;\n    let start = this._findNearestItem(offset);\n    let stop = start;\n\n    const datum = this.getSizeAndPositionForIndex(start);\n    offset = datum.offset + datum.size;\n\n    while (offset < maxOffset && stop < this._itemCount - 1) {\n      stop++;\n      offset += this.getSizeAndPositionForIndex(stop).size;\n    }\n\n    if (overscanCount) {\n      start = Math.max(0, start - overscanCount);\n      stop = Math.min(stop + overscanCount, this._itemCount);\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n\n  /**\n   * Clear all cached values for items after the specified index.\n   * This method should be called for any item that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n   */\n  resetItem(index) {\n    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n  }\n\n  _binarySearch({low, high, offset}) {\n    let middle;\n    let currentOffset;\n\n    while (low <= high) {\n      middle = low + Math.floor((high - low) / 2);\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n\n      if (currentOffset === offset) {\n        return middle;\n      } else if (currentOffset < offset) {\n        low = middle + 1;\n      } else if (currentOffset > offset) {\n        high = middle - 1;\n      }\n    }\n\n    if (low > 0) {\n      return low - 1;\n    }\n  }\n\n  _exponentialSearch({index, offset}) {\n    let interval = 1;\n\n    while (\n      index < this._itemCount &&\n      this.getSizeAndPositionForIndex(index).offset < offset\n    ) {\n      index += interval;\n      interval *= 2;\n    }\n\n    return this._binarySearch({\n      high: Math.min(index, this._itemCount - 1),\n      low: Math.floor(index / 2),\n      offset,\n    });\n  }\n\n  /**\n   * Searches for the item (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest item index will be returned.\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\n   */\n  _findNearestItem(offset) {\n    if (isNaN(offset)) {\n      throw Error(`Invalid offset ${offset} specified`);\n    }\n\n    // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n    offset = Math.max(0, offset);\n\n    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    const lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);\n\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\n      // If we've already measured items within this range just use a binary search as it's faster.\n      return this._binarySearch({\n        high: lastMeasuredIndex,\n        low: 0,\n        offset,\n      });\n    } else {\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n      // The overall complexity for this approach is O(log n).\n      return this._exponentialSearch({\n        index: lastMeasuredIndex,\n        offset,\n      });\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/SizeAndPositionManager.js","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n// module id = 3\n// module chunks = 0"],"sourceRoot":""}